# go 协程 #

goroutine的本质是协程，是实现并行计算的核心


在分析原理之前，了解下一些关键性术语的概念。

## 并发 ##

一个cpu上能同时执行多项任务，在很短时间内，cpu来回切换任务执行(在某段很短时间内执行程序a，然后又迅速切换到程序b去执行)，宏观上是同时的，微观仍是顺序执行，这样看起来多个任务像是同时执行，这就是并发。

## 并行 ##

当系统有多个CPU时,每个CPU同一时刻都运行任务，互不抢占自己所在的CPU资源，同时进行，称为并行。

## 进程 ##
cpu在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的context--上下文），直接切换下一个程序，就会丢失上一个程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。

## 线程 ##

cpu切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，内核态的系统调用耗费资源比较多，耗时也比较久，进程一旦多起来，cpu调度会消耗一大堆资源，因此引入了线程的概念。线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不会像进程切换那么耗费资源。

这里说的线程指的还是内核线程。或者说是是**轻量级进程**（内核支持的用户线程）。进行切换的时候需要系统调用。

## 协程 ##

协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程。

这里协程对应的就是恐龙书中的多对多模型。



![](https://raw.githubusercontent.com/ernest-dzf/docs/master/pic/lwp2.JPG)

## goroutine ##

goroutine在堆里申请一块内存，然后把它当作栈来用。